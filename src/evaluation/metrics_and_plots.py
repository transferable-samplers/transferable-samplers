import logging
from typing import Callable, Optional

from src.data.preprocessing.tica import TicaModel
from src.evaluation.metrics.evaluate_peptide_data import evaluate_peptide_data
from src.evaluation.plots.plot_atom_distances import plot_atom_distances
from src.evaluation.plots.plot_com_norms import plot_com_norms
from src.evaluation.plots.plot_energies import plot_energies
from src.evaluation.plots.plot_ramachandran import plot_ramachandran
from src.evaluation.plots.plot_tica import plot_tica
from src.utils.data_types import SamplesData


def metrics_and_plots(
    log_image_fn: Callable,
    sequence: str,
    topology: object,  # mdtraj.Topology
    tica_model: TicaModel,
    num_eval_samples: int,
    true_data: SamplesData,
    proposal_data: SamplesData,
    resampled_data: SamplesData,
    smc_data: Optional[SamplesData] = None,
    do_plots: bool = True,
    prefix: str = "",
) -> dict:
    """
    Compute evaluation metrics and log diagnostic plots for model outputs.

    Logs Ramachandran plots, TICA projections, energy distributions, atom
    distance distributions, and center-of-mass norms for provided datasets.
    Also computes quantitative evaluation metrics by comparing generated
    samples against true reference data.

    Args:
        log_image_fn (Callable): Function used to log or save generated plots.
        sequence (str): Peptide sequence identifier.
        topology: Topology object for the peptide.
        tica_model (TicaModel): TICA model used for projections.
        num_eval_samples (int): Number of samples to use for evaluation.
        true_data (SamplesData): Reference trajectory samples and energies.
        proposal_data (SamplesData): Samples generated by the proposal distribution.
        resampled_data (SamplesData): Samples after resampling.
        smc_data (Optional[SamplesData], optional): Samples from SMC if available.
        do_plots (bool, optional): Whether to generate plots. Defaults to True.
        prefix (str, optional): String prefix to prepend to log keys.

    Returns:
        dict: Dictionary mapping metric names to computed values.
    """
    if len(prefix) > 0 and prefix[-1] != "/":
        prefix += "/"

    metrics = {}
    if do_plots:
        plot_ramachandran(
            log_image_fn,
            true_data.samples,
            topology,
            prefix=prefix + "true",
        )
        plot_tica(
            log_image_fn,
            true_data.samples,
            topology,
            tica_model,
            prefix=prefix + "true",
        )

    for data, name in [
        [proposal_data, "proposal"],
        [resampled_data, "resampled"],
        [smc_data, "smc"],
    ]:
        if data is None and name == "smc":
            continue

        if len(data) == 0:
            logging.warning(f"No {name} samples present.")
            continue

        logging.info(f"Evaluating {prefix + name} samples")

        data = data[:num_eval_samples * 2]  # slice out extra samples for those lost to symmetry

        metrics.update(
            evaluate_peptide_data(
                true_data,
                data,
                topology=topology,
                tica_model=tica_model,
                num_eval_samples=num_eval_samples,
                prefix=prefix + name,
                compute_distribution_distances=False,
            )
        )
        if do_plots:
            plot_ramachandran(log_image_fn, data.samples, topology, prefix=prefix + name)
            plot_tica(
                log_image_fn,
                data.samples,
                topology,
                tica_model=tica_model,
                prefix=prefix + name,
            )

    # reduce size so plotting doesn't crash with many samples
    true_data = true_data[:num_eval_samples]
    proposal_data = proposal_data[:num_eval_samples]
    resampled_data = resampled_data[:num_eval_samples]
    smc_data = smc_data[:num_eval_samples] if smc_data is not None else None

    if do_plots:
        plot_energies(
            log_image_fn,
            true_data.energy,
            proposal_data.energy if len(proposal_data) > 0 else None,
            resampled_data.energy if len(resampled_data) > 0 else None,
            smc_data.energy if (smc_data is not None and len(smc_data) > 0) else None,
            prefix=prefix,
        )
        plot_atom_distances(
            log_image_fn,
            true_data.samples,
            proposal_data.samples if len(proposal_data) > 0 else None,
            resampled_data.samples if len(resampled_data) > 0 else None,
            smc_data.samples if (smc_data is not None and len(smc_data) > 0) else None,
            prefix=prefix,
        )
        plot_com_norms(
            log_image_fn,
            proposal_data.samples if len(proposal_data) > 0 else None,
            resampled_data.samples if len(resampled_data) > 0 else None,
            smc_data.samples if (smc_data is not None and len(smc_data) > 0) else None,
            prefix=prefix,
        )

    return metrics

